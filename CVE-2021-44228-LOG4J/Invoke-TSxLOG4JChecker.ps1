<#
.VERSION 1.7
1.7 - Changed name of output folder
1.6 - Removed function Get-TsXLOG4J, placed code directly in script.
1.5 - Added error handling when reading zip files
1.4 - Check file size before extracting files.
1.3 - Add Random number to extracted files name, to handle files with same name.
1.2 - Rewrite helper functions.
1.1 - Rewrite check for java files inside other java files to handle nested files within nested files, until all is found.
1.0 - Initial release.

.DESCRIPTION
This script checks log4j precense on the system it is executed on.
The checks performed are detailed within the script and nothing but the detailed actions are performed as part of the execution.

Place the script in a folder and execute the script elevated with administrative privileges, the script will create a subfolder where it will create the result files.
For remote execution on multiple systems, the script can be copied to Windows\Temp folder and executed there. Invoke-Command, Invoke-WmiMethod, use of psexec etc. or other means of remote execution should be valid.
Remember to copy back the results to some central location if executed remotely.
Please note that executing on multiple systems might have inpact on eventual underlaying infrastructure - make sure to execute in smaller batches accordingly.

Ensure that the disclaimer is read and understood before execution!

.NOTES
 Author: Truesec Cyber Security Incident Response Team
 Website: https://truesec.com/
 Created: 2021-12-12

 Compatibility: The script has been tested and verified on PowerShell version 3 and 5

 .DISCLAIMER
 Any of use of this script should be performed by qualified professionals with the necessary knowledge and skills to make independent conclusions.
 The script does not guarantee or in any way ensure, promise or indicate that after successful execution, a system can be declared as safe.
 The script should be used as a tool to help identify indicators of log4j precense on the system it is executed on.

#>

# Set WorkPath
$WorkPath = "$PSScriptRoot\LOG4JCollection"

# Check if WorkPath folder exist, create if false
if (!(Test-Path -Path $WorkPath)) {
    New-Item $WorkPath -type directory
}

# Check if Temp folder exist, create if false
# Used for unpacking *.war and *.ear files
if (!(Test-Path -Path "$WorkPath\temp")) {
    New-Item "$WorkPath\temp" -type directory
}

# Get timestamp to use in naming of file with results
$TimeStamp = Get-Date -UFormat "%Y%m%d.%H%M%S"

# Start transcript
Start-Transcript $WorkPath\$($env:COMPUTERNAME)_PowerShellTranscript_$TimeStamp.txt

# Add FileSystem typ, to be used in Find-LOG4JMatch and Expand-JavaFiles functions
Add-Type -AssemblyName System.IO.Compression.FileSystem

# Add Find-LOG4JMatch function to list content in Java files (*.jar, *.war and *.ear) and look for "log4j", "jndilookup", "jndimanager" and "socketnode"function Find-LOG4JMatch {
function Find-LOG4JMatch {
    param([string]$FileToCheck)
    try {
        # Open the java file
        $ZipFile = [io.compression.zipfile]::OpenRead("$FileToCheck")
    
        # Look for files inside the java file
        $Check = $ZipFile.Entries | Where-Object { $_.Name -match "log4j" -or $_.Name -match "jndilookup" -or $_.Name -match "jndimanager" -or $_.Name -match "socketnode" }
    
        # Dispose the open zipfile, otherwise it will be locked
        $ZipFile.Dispose()
    
        # Return found files in the java file
        $Check
    }
    catch {
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Error when working with: $FileToCheck" -ForegroundColor Yellow
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - $($error[0].Exception.Message)" -ForegroundColor Yellow
    }
}

# Add Expand-JavaFile extract java files from inside Java files (*.jar, *.war and *.ear)
Function Expand-JavaFile {
    param([string]$Path)

    # Get the file name from the input
    $FileName = Split-Path $Path -Leaf

    # Open the java file
    $ZipFile = [io.compression.zipfile]::OpenRead($Path)

    # Get all files with java extensions
    $NestedJavaFiles = $ZipFile.Entries | Where-Object { $_.Name -like "*.jar" -or $_.Name -like "*.war" -or $_.Name -like "*.ear" }

    # Extract found files
    foreach ($File in $NestedJavaFiles) {

        # Create a random number for use in temporary file name
        $rnd = Get-Random -Maximum 9999 -Minimum  1000

        # Write to host for transcript reason
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Found nested jar file inside $FileName" -ForegroundColor Yellow
        
        If ($file.Length -gt 0) {
            Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Temporary unpacking $($File.name) to $WorkPath\temp\$($FileName)-$rnd---$($File.name)" -ForegroundColor Yellow

            try {
                # Extract the file, add a prefix to the extracted files (source.jar---foundfile.jar)
                [System.IO.Compression.ZipFileExtensions]::ExtractToFile($file, "$WorkPath\temp\$FileName-$rnd---$($File.name)")
            }
            catch {
                # Write to host for transcript reason
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Error, something went wrong when trying to extract files from $Path" -ForegroundColor Yellow
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - $error[0].Exception.Message" -ForegroundColor Yellow
            }

        }
        else {
    
            Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Size is $($File.Length), skipping" -ForegroundColor Yellow
        }

    }

    # Dispose the open zipfile, otherwise it will be locked
    $ZipFile.Dispose()
}

# Get all drives
$Drives = Get-PSDrive -PSProvider FileSystem

# Array to keep track of extracted jar files
$ExtractedFiles = @()

# Execute search, one drive at the time
Foreach ($Drive in $Drives) {

    # Write to host for transcript reason
    Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Searching on $($Drive.name) this will take a few minutes..." -ForegroundColor Yellow

    # Find all Java files (*.jar, *.war and *.ear) and store in a variable
    $JavaFiles = Get-ChildItem $Drive.Root -Recurse -Force -Include *.jar, *.war, *.ear -ErrorAction SilentlyContinue -Verbose

    # Write to host for transcript reason
    Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Done searching on $($Drive.name)" -ForegroundColor Yellow

    # Execute search for matches, one Java file at the time
    foreach ($JavaFile in $JavaFiles) {

        # Write filename to COMPUTERNAME_java_files_TIMESTAMP.txt
        $JavaFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_java_files_$TimeStamp.txt

        # Write to host for transcript reason
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Checking $JavaFile" -ForegroundColor Yellow

        # Check Java file and write to file if there's a match
        if (Find-LOG4JMatch -FileToCheck $JavaFile) {

            # Write to host for transcript reason
            Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Positive indication found, writing to $($env:COMPUTERNAME)_matches_$TimeStamp.txt" -ForegroundColor Yellow

            # Write filename to COMPUTERNAME_matches_TIMESTAMP.txt
            $JavaFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_matches_$TimeStamp.txt
        }

        # Write to host for transcript reason
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Checking Inside $JavaFile for nested files" -ForegroundColor Yellow

        # Check the Java file for nested java files, unpack found files to temp in working directory
        Expand-JavaFile -Path $JavaFile.FullName

        # Get all files in temp directory, and check for java files inside, this part will run until no new files is found
        do {

            # Get all java files that have not already been checked and added to the array ExtractedFiles
            $NestedJavaFiles = Get-ChildItem  "$WorkPath\temp" | Where-Object Name -notin $ExtractedFiles

            # Check all new extracted files
            foreach ($file in $NestedJavaFiles) {

                # Write filename to COMPUTERNAME_java_files_TIMESTAMP.txt
                $file.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_java_files_$TimeStamp.txt

                # Check for jar files in extracted java file
                Expand-JavaFile -Path $File.FullName

                # Add file name to array to skip file on next check
                $ExtractedFiles += $File.name
            }

        }
        # Do above part until NestedJavaFiles dosent contain no more files
        until ($NestedJavaFiles.count -eq 0)

    }

    # Get all nested java files in temporary folder
    $NestedFiles = Get-ChildItem "$WorkPath\temp\" -Recurse -Force -Include *.jar, *.war, *.ear -ErrorAction SilentlyContinue -Verbose

    # Execute search for matches, one Java file at the time
    foreach ($NestedFile in $NestedFiles) {

        # Check Java file and write to file if there's a match
        if (Find-LOG4JMatch $NestedFile) {

            # Write to host for transcript reason
            Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Positive indication found in nested file $($NestedFile.FullName), writing to $($env:COMPUTERNAME)_matches_$TimeStamp.txt" -ForegroundColor Yellow

            # Write filename to COMPUTERNAME_matches_TIMESTAMP.txt
            $NestedFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_matches_$TimeStamp.txt
        }

    }

}

# Write to host for transcript reason
Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Removing temporary folder $WorkPath\temp" -ForegroundColor Yellow

# Remove Temp folder
Remove-Item $WorkPath\temp -Recurse -Force

# End transcript
Stop-Transcript